"""
Helper and processing functions for tree interpolation.

This module contains utility functions for processing split data,
extracting data, and managing the interpolation workflow.
"""

from __future__ import annotations

from typing import Any, Dict, List, Optional, Tuple
from brancharchitect.tree import Node
from brancharchitect.elements.partition import Partition
from brancharchitect.elements.partition_set import PartitionSet
from brancharchitect.tree_interpolation.consensus_tree.consensus_tree import (
    create_collapsed_consensus_tree,
)
from brancharchitect.tree_interpolation.consensus_tree.intermediate_tree import (
    create_subtree_grafted_tree,
    calculate_intermediate_implicit,
    apply_reference_weights_to_path,
)
from .reordering import reorder_tree_toward_destination


def extract_filtered_paths(
    selection: Dict[str, Any],
    current_pivot_edge: Partition,
) -> Tuple[List[Partition], List[Partition]]:
    """
    Extract expand/collapse paths from a selection and filter out structural boundaries.

    This function ensures that the active pivot edge and the subtree root are never
    included in the modification paths, preventing accidental deletion of the
    interpolation scope's boundaries.

    Args:
        selection: Dictionary containing 'expand' and 'collapse' path segments from the planner.
        current_pivot_edge: The active-changing split (boundary) to exclude from modification.

    Returns:
        Tuple[List[Partition], List[Partition]]: A tuple containing:
            - expand_path: List of partitions to be created/expanded (filtered).
            - collapse_path: List of partitions to be collapsed (filtered).
    """
    subtree_partition = selection["subtree"]
    exclusions = {current_pivot_edge, subtree_partition}

    # Extract path segments - now guaranteed to be lists from builder
    expand_segments: List[Partition] = selection.get("expand", {}).get(
        "path_segment", []
    )
    collapse_segments: List[Partition] = selection.get("collapse", {}).get(
        "path_segment", []
    )

    expand_path: List[Partition] = [p for p in expand_segments if p not in exclusions]

    collapse_path: List[Partition] = [
        p for p in collapse_segments if p not in exclusions
    ]

    return expand_path, collapse_path


def add_step(
    trees: List[Node],
    edges: List[Optional[Partition]],
    tree: Node,
    edge: Optional[Partition],
    subtree: Partition,
    subtree_tracker: Optional[List[Partition]] = None,
) -> None:
    """Add a tree and edge to the collection of microsteps.

    Args:
        trees: List to append the tree to
        edges: List to append the edge to
        tree: The tree to add
        edge: The edge to add
        subtree: The subtree partition for this step
        subtree_tracker: Optional list to track subtree partitions per step
    """
    trees.append(tree)
    edges.append(edge)
    if subtree_tracker is not None:
        subtree_tracker.append(subtree)


def build_microsteps_for_selection(
    interpolation_state: Node,
    destination_tree: Node,
    current_pivot_edge: Partition,
    selection: Dict[str, Any],
) -> Tuple[List[Node], List[Optional[Partition]], Node, List[Partition]]:
    """
    Build the 5 microsteps for a single selection under an active-changing edge.

    Steps:
    - IT_down: collapse zeros inside the subtree selection
    - C: collapse zero-length branches to consensus
    - C_reorder: partially reorder to match the destination
    - IT_up: graft the reference path while preserving order
    - IT_ref: apply final reference weights on the grafted path

    Args:
        interpolation_state: The current tree state before applying this selection's steps.
        destination_tree: The final target tree (used for weight lookups and consensus checks).
        current_pivot_edge: The active-changing split (pivot edge) currently being processed.
        selection: A dictionary containing the 'subtree' partition and its 'expand'/'collapse' paths.

    Returns:
        Tuple containing:
        - List[Node]: The sequence of 5 intermediate trees generated by this selection.
        - List[Optional[Partition]]: The pivot edge associated with each step (for tracking).
        - Node: The final tree state after applying all microsteps (snapped_tree).
        - List[Partition]: The subtree partition associated with each step (for tracking).
    """
    trees: List[Node] = []
    edges: List[Optional[Partition]] = []

    # Extract and filter path segments using the modularized function
    subtree_partition = selection["subtree"]

    expand_path, collapse_path = extract_filtered_paths(selection, current_pivot_edge)

    # Guard: ensure we do not collapse splits that must exist in destination
    it_down: Node = calculate_intermediate_implicit(
        interpolation_state, PartitionSet(set(collapse_path))
    )

    subtree_tracker: List[Partition] = []

    add_step(
        trees,
        edges,
        it_down,
        current_pivot_edge,
        subtree_partition,
        subtree_tracker=subtree_tracker,
    )

    # FIX: Pass destination tree so we only collapse splits that DON'T exist in destination
    collapsed: Node = create_collapsed_consensus_tree(
        it_down, current_pivot_edge, destination_tree=destination_tree
    )

    add_step(
        trees,
        edges,
        collapsed,
        current_pivot_edge,
        subtree_partition,
        subtree_tracker=subtree_tracker,
    )

    # Apply partial reordering based on the interpolation context
    reordered: Node = reorder_tree_toward_destination(
        source_tree=collapsed,
        destination_tree=destination_tree,
        current_pivot_edge=current_pivot_edge,
        moving_subtree_partition=subtree_partition,
    )

    add_step(
        trees,
        edges,
        reordered,
        current_pivot_edge,
        subtree_partition,
        subtree_tracker=subtree_tracker,
    )

    # Graft with order preservation to eliminate second reordering step
    pre_snap_reordered: Node = create_subtree_grafted_tree(
        base_tree=reordered,
        ref_path_to_build=expand_path,
    )

    # Align ordering once after graft so both microsteps share identical layout
    pre_snap_reordered.reorder_taxa(list(reordered.get_current_order()))
    snapped_tree: Node = pre_snap_reordered.deep_copy()

    # Normalize earlier steps to the final snapped ordering to prevent churn
    final_order = list(snapped_tree.get_current_order())
    reordered.reorder_taxa(final_order)
    pre_snap_reordered.reorder_taxa(final_order)

    # Extract destination weights from the destination tree
    destination_weights: Dict[Partition, float] = destination_tree.to_weighted_splits()

    apply_reference_weights_to_path(
        snapped_tree,
        expand_path,
        destination_weights,
    )

    add_step(
        trees,
        edges,
        pre_snap_reordered,
        current_pivot_edge,
        subtree_partition,
        subtree_tracker=subtree_tracker,
    )

    add_step(
        trees,
        edges,
        snapped_tree,
        current_pivot_edge,
        subtree_partition,
        subtree_tracker=subtree_tracker,
    )

    return trees, edges, snapped_tree, subtree_tracker
