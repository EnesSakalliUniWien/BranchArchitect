"""
Helper and processing functions for tree interpolation.

This module contains utility functions for processing split data,
extracting data, and managing the interpolation workflow.
"""

from __future__ import annotations

from typing import Any, Dict, List, Optional, Tuple
from brancharchitect.tree import Node
from brancharchitect.elements.partition import Partition
from brancharchitect.elements.partition_set import PartitionSet
from brancharchitect.tree_interpolation.topology_ops.collapse import (
    create_collapsed_consensus_tree,
)
from brancharchitect.tree_interpolation.topology_ops.weights import (
    apply_zero_branch_lengths,
    apply_reference_weights_to_path,
)
from brancharchitect.tree_interpolation.topology_ops.expand import (
    create_subtree_grafted_tree,
)
from .reordering import reorder_tree_toward_destination


def extract_filtered_paths(
    selection: Dict[str, Any],
    current_pivot_edge: Partition,
) -> Tuple[List[Partition], List[Partition]]:
    """
    Extract expand/zeroing paths from a selection and filter out structural boundaries.

    This function ensures that the active pivot edge is never included in the
    modification paths, preventing accidental deletion of the interpolation scope's
    boundary.

    Note: The subtree partition is only excluded from the EXPAND path (to prevent
    creating a split that already exists), but NOT from the COLLAPSE path (because
    the subtree might be a collapse split that needs to be removed).

    Args:
        selection: Dictionary containing 'expand' and 'collapse' path segments from the planner.
        current_pivot_edge: The active-changing split (boundary) to exclude from modification.

    Returns:
        Tuple[List[Partition], List[Partition]]: A tuple containing:
            - expand_path: List of partitions to be created/expanded (filtered).
            - zeroing_path: List of partitions to be set to zero length (filtered).
    """
    subtree_partition = selection["subtree"]

    # Pivot edge is always excluded from both paths (it's the boundary)
    # Subtree partition is only excluded from expand path (not collapse)
    expand_exclusions = {current_pivot_edge, subtree_partition}
    collapse_exclusions = {current_pivot_edge}  # Don't exclude subtree from collapse!

    # Extract path segments - now guaranteed to be lists from builder
    expand_segments: List[Partition] = selection.get("expand", {}).get(
        "path_segment", []
    )
    zeroing_segments: List[Partition] = selection.get("collapse", {}).get(
        "path_segment", []
    )

    expand_path: List[Partition] = [
        p for p in expand_segments if p not in expand_exclusions
    ]

    zeroing_path: List[Partition] = [
        p for p in zeroing_segments if p not in collapse_exclusions
    ]

    return expand_path, zeroing_path


def add_step(
    trees: List[Node],
    edges: List[Optional[Partition]],
    tree: Node,
    edge: Optional[Partition],
    subtree: Partition,
    subtree_tracker: Optional[List[Partition]] = None,
) -> None:
    """Add a tree and edge to the collection of microsteps.

    Args:
        trees: List to append the tree to
        edges: List to append the edge to
        tree: The tree to add
        edge: The edge to add
        subtree: The subtree partition for this step
        subtree_tracker: Optional list to track subtree partitions per step
    """
    trees.append(tree)
    edges.append(edge)
    if subtree_tracker is not None:
        subtree_tracker.append(subtree)


def build_microsteps_for_selection(
    interpolation_state: Node,
    destination_tree: Node,
    current_pivot_edge: Partition,
    selection: Dict[str, Any],
) -> Tuple[List[Node], List[Optional[Partition]], Node, List[Partition]]:
    """
    Build the 5 microsteps for a single selection under an active-changing edge.

    Steps:
    - IT_down: set branch lengths to zero inside the subtree selection
    - C: collapse zero-length branches to consensus topology
    - C_reorder: partially reorder to match the destination
    - IT_up: graft the reference path while preserving order
    - IT_ref: apply final reference weights on the grafted path

    Args:
        interpolation_state: The current tree state before applying this selection's steps.
        destination_tree: The final target tree (used for weight lookups and consensus checks).
        current_pivot_edge: The active-changing split (pivot edge) currently being processed.
        selection: A dictionary containing the 'subtree' partition and its 'expand'/'collapse' paths.

    Returns:
        Tuple containing:
        - List[Node]: The sequence of 5 intermediate trees generated by this selection.
        - List[Optional[Partition]]: The pivot edge associated with each step (for tracking).
        - Node: The final tree state after applying all microsteps (snapped_tree).
        - List[Partition]: The subtree partition associated with each step (for tracking).
    """
    trees: List[Node] = []
    edges: List[Optional[Partition]] = []

    # Extract and filter path segments using the modularized function
    subtree_partition = selection["subtree"]

    expand_path, zeroing_path = extract_filtered_paths(selection, current_pivot_edge)

    # Guard: ensure we do not zero splits that must exist in destination
    it_down: Node = apply_zero_branch_lengths(
        interpolation_state, PartitionSet(set(zeroing_path))
    )

    subtree_tracker: List[Partition] = []

    add_step(
        trees,
        edges,
        it_down,
        current_pivot_edge,
        subtree_partition,
        subtree_tracker=subtree_tracker,
    )

    # FIX: Pass destination tree so we only collapse splits that DON'T exist in destination
    # Use copy=False since it_down is only used here and we need a fresh tree for collapsed
    collapsed: Node = create_collapsed_consensus_tree(
        it_down, current_pivot_edge, destination_tree=destination_tree, copy=True
    )

    add_step(
        trees,
        edges,
        collapsed,
        current_pivot_edge,
        subtree_partition,
        subtree_tracker=subtree_tracker,
    )

    # Apply partial reordering based on the interpolation context
    # Use copy=True since collapsed is stored in trees list
    reordered: Node = reorder_tree_toward_destination(
        source_tree=collapsed,
        destination_tree=destination_tree,
        current_pivot_edge=current_pivot_edge,
        moving_subtree_partition=subtree_partition,
        copy=True,
    )

    add_step(
        trees,
        edges,
        reordered,
        current_pivot_edge,
        subtree_partition,
        subtree_tracker=subtree_tracker,
    )

    # Graft with order preservation to eliminate second reordering step
    # Use copy=True since reordered is stored in trees list
    pre_snap_reordered: Node = create_subtree_grafted_tree(
        base_tree=reordered,
        ref_path_to_build=expand_path,
        copy=True,
    )

    # Align ordering once after graft so both microsteps share identical layout
    pre_snap_reordered.reorder_taxa(list(reordered.get_current_order()))
    # Use deep_copy for snapped_tree since pre_snap_reordered will be modified
    snapped_tree: Node = pre_snap_reordered.deep_copy()

    # Normalize earlier steps to the final snapped ordering to prevent churn
    final_order = list(snapped_tree.get_current_order())
    reordered.reorder_taxa(final_order)
    pre_snap_reordered.reorder_taxa(final_order)

    # Extract destination weights from the destination tree
    destination_weights: Dict[Partition, float] = destination_tree.to_weighted_splits()

    apply_reference_weights_to_path(
        snapped_tree,
        expand_path,
        destination_weights,
    )

    add_step(
        trees,
        edges,
        pre_snap_reordered,
        current_pivot_edge,
        subtree_partition,
        subtree_tracker=subtree_tracker,
    )

    add_step(
        trees,
        edges,
        snapped_tree,
        current_pivot_edge,
        subtree_partition,
        subtree_tracker=subtree_tracker,
    )

    return trees, edges, snapped_tree, subtree_tracker
