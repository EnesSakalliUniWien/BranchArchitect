"""
Step Executor for Subtree-Path Interpolation

Executes the stepwise plan for pivot edges and generates animation frames
for visualizing subtree movement between phylogenetic tree topologies.

Key Stages (5 per selection):
1. Collapse Down: Zero-length branches inside the moving subtree
2. Collapse: Merge zero-length branches into consensus topology
3. Reorder: Place the subtree at its new position among stable anchors
4. Expand Up: Restore branch lengths from destination tree
5. Snap: Final state matching the destination topology
"""

from __future__ import annotations

from typing import Any, Dict, List, Optional, Tuple
import logging

from brancharchitect.tree import Node
from brancharchitect.elements.partition import Partition
from brancharchitect.elements.partition_set import PartitionSet
from brancharchitect.tree_interpolation.topology_ops.collapse import (
    create_collapsed_consensus_tree,
)
from brancharchitect.tree_interpolation.topology_ops.weights import (
    apply_zero_branch_lengths,
    apply_reference_weights_to_path,
)
from brancharchitect.tree_interpolation.topology_ops.expand import (
    create_subtree_grafted_tree,
)
from ..planning import build_edge_plan
from .reordering import reorder_tree_toward_destination, align_to_source_order

# Suppress the diagnostics logger
logging.getLogger("brancharchitect.logger.interpolation_logger").setLevel(
    logging.WARNING
)


# ============================================================================
# Microstep Building Functions
# ============================================================================


def _add_step(
    trees: List[Node],
    edges: List[Optional[Partition]],
    tree: Node,
    edge: Optional[Partition],
    subtree: Partition,
    subtree_tracker: Optional[List[Partition]] = None,
) -> None:
    """Add a tree and edge to the collection of microsteps.

    Args:
        trees: List to append the tree to
        edges: List to append the edge to
        tree: The tree to add
        edge: The edge to add
        subtree: The subtree partition for this step
        subtree_tracker: Optional list to track subtree partitions per step
    """
    trees.append(tree)
    edges.append(edge)
    if subtree_tracker is not None:
        subtree_tracker.append(subtree)


def build_microsteps_for_selection(
    interpolation_state: Node,
    destination_tree: Node,
    current_pivot_edge: Partition,
    selection: Dict[str, Any],
    all_mover_partitions: Optional[List[Partition]] = None,
    source_parent_map: Optional[Dict[Partition, Partition]] = None,
    dest_parent_map: Optional[Dict[Partition, Partition]] = None,
) -> Tuple[List[Node], List[Optional[Partition]], Node, List[Partition]]:
    """
    Build the 5 microsteps for a single selection under an active-changing edge.

    Steps:
    - IT_down: set branch lengths to zero inside the subtree selection
    - C: collapse zero-length branches to consensus topology
    - C_reorder: partially reorder to match the destination
    - IT_up: graft the reference path while preserving order
    - IT_ref: apply final reference weights on the grafted path

    Args:
        interpolation_state: The current tree state before applying this selection's steps.
        destination_tree: The final target tree (used for weight lookups and consensus checks).
        current_pivot_edge: The active-changing split (pivot edge) currently being processed.
        selection: A dictionary containing the 'subtree' partition and its 'expand'/'collapse' paths.
        all_mover_partitions: List of all moving subtree Partitions (blocks) for this pivot edge.
                              Used to identify stable anchor blocks vs moving blocks.
        source_parent_map: Maps each mover -> its parent in source tree (from map_solution_elements_via_parent).
        dest_parent_map: Maps each mover -> its parent in destination tree (from map_solution_elements_via_parent).

    Returns:
        Tuple containing:
        - List[Node]: The sequence of 5 intermediate trees generated by this selection.
        - List[Optional[Partition]]: The pivot edge associated with each step (for tracking).
        - Node: The final tree state after applying all microsteps (snapped_tree).
        - List[Partition]: The subtree partition associated with each step (for tracking).
    """
    trees: List[Node] = []
    edges: List[Optional[Partition]] = []
    subtree_tracker: List[Partition] = []

    # Extract path segments directly from selection
    # Note: Paths are already filtered upstream in calculate_subtree_paths (transition_builder.py)
    # which removes pivot_edge from both paths and subtree from collapse path
    subtree_partition = selection["subtree"]
    expand_path: List[Partition] = selection.get("expand", {}).get("path_segment", [])
    zeroing_path: List[Partition] = selection.get("collapse", {}).get(
        "path_segment", []
    )

    # Step 1: Collapse Down - zero branch lengths
    it_down: Node = apply_zero_branch_lengths(
        interpolation_state, PartitionSet(set(zeroing_path))
    )
    _add_step(
        trees, edges, it_down, current_pivot_edge, subtree_partition, subtree_tracker
    )

    # Step 2: Collapse - merge zero-length branches
    collapsed: Node = create_collapsed_consensus_tree(
        it_down, current_pivot_edge, destination_tree=destination_tree, copy=True
    )
    _add_step(
        trees, edges, collapsed, current_pivot_edge, subtree_partition, subtree_tracker
    )

    # Step 3: Reorder - place subtree at new position
    reordered: Node = reorder_tree_toward_destination(
        source_tree=collapsed,
        destination_tree=destination_tree,
        current_pivot_edge=current_pivot_edge,
        moving_subtree_partition=subtree_partition,
        all_mover_partitions=all_mover_partitions,
        source_parent_map=source_parent_map,
        dest_parent_map=dest_parent_map,
        copy=True,
    )

    _add_step(
        trees, edges, reordered, current_pivot_edge, subtree_partition, subtree_tracker
    )

    # Step 4 & 5: Expand Up and Snap
    pre_snap_reordered: Node = create_subtree_grafted_tree(
        base_tree=reordered,
        ref_path_to_build=expand_path,
        copy=True,
    )

    pre_snap_reordered.reorder_taxa(list(reordered.get_current_order()))

    # Use align_to_source_order to preserve non-mover positions after graft
    align_to_source_order(
        pre_snap_reordered,
        source_order=list(reordered.get_current_order()),
        moving_taxa=subtree_partition.taxa,
    )

    # Align ordering once after graft so both microsteps share identical layout
    snapped_tree: Node = pre_snap_reordered.deep_copy()

    # Normalize to final snapped ordering
    final_order = list(snapped_tree.get_current_order())
    pre_snap_reordered.reorder_taxa(final_order)

    # Apply destination weights
    destination_weights: Dict[Partition, float] = destination_tree.to_weighted_splits()
    apply_reference_weights_to_path(snapped_tree, expand_path, destination_weights)

    reordered.reorder_taxa(list(snapped_tree.get_current_order()))

    _add_step(
        trees,
        edges,
        pre_snap_reordered,
        current_pivot_edge,
        subtree_partition,
        subtree_tracker,
    )
    _add_step(
        trees,
        edges,
        snapped_tree,
        current_pivot_edge,
        subtree_partition,
        subtree_tracker,
    )

    return trees, edges, snapped_tree, subtree_tracker


# ============================================================================
# Edge Plan Execution
# ============================================================================


def apply_stepwise_plan_for_edge(
    current_base_tree: Node,
    destination_tree: Node,
    current_pivot_edge: Partition,
    expand_paths_for_pivot_edge: Dict[Partition, PartitionSet[Partition]],
    collapse_paths_for_pivot_edge: Dict[Partition, PartitionSet[Partition]],
    source_parent_map: Optional[Dict[Partition, Partition]] = None,
    dest_parent_map: Optional[Dict[Partition, Partition]] = None,
) -> Tuple[List[Node], List[Optional[Partition]], Node, List[Partition]]:
    """
    Executes the stepwise plan for one pivot edge across all selections.

    Args:
        current_base_tree: The current tree state
        destination_tree: The destination tree we're morphing toward
        current_pivot_edge: The pivot edge (active-changing split) being processed
        expand_paths_for_pivot_edge: Paths for partitions that will be expanded
        collapse_paths_for_pivot_edge: Paths for partitions that will be collapsed

    Returns:
        Tuple of (trees, edges, interpolation_state, subtree_tracker)
    """
    trees: List[Node] = []
    edges: List[Optional[Partition]] = []
    subtree_tracker: List[Partition] = []
    interpolation_state: Node = current_base_tree

    selections: Dict[Partition, Dict[str, Any]] = build_edge_plan(
        expand_paths_for_pivot_edge,
        collapse_paths_for_pivot_edge,
        current_base_tree,
        destination_tree,
        current_pivot_edge=current_pivot_edge,
    )

    # Debug logging
    logging.debug(f"\\nSelections for edge {current_pivot_edge}:")
    for subtree, selection in selections.items():
        logging.debug(f"\\nSubtree: {subtree}")
        if "collapse" in selection and "path_segment" in selection["collapse"]:
            collapse_paths = selection["collapse"]["path_segment"]
            logging.debug(f"  Collapse paths ({len(collapse_paths)}):")
            for path in collapse_paths:
                logging.debug(f"    - {path}")
        if "expand" in selection and "path_segment" in selection["expand"]:
            expand_paths = selection["expand"]["path_segment"]
            logging.debug(f"  Expand paths ({len(expand_paths)}):")
            for path in expand_paths:
                logging.debug(f"    - {path}")

    # All mover partitions as BLOCKS (not flattened to taxa)
    all_mover_partitions: List[Partition] = list(selections.keys())

    for subtree, selection in selections.items():
        # Add subtree to selection for compatibility
        selection_with_subtree: Dict[str, Any] = {**selection, "subtree": subtree}

        step_trees, step_edges, interpolation_state, step_subtree_tracker = (
            build_microsteps_for_selection(
                interpolation_state=interpolation_state,
                destination_tree=destination_tree,
                current_pivot_edge=current_pivot_edge,
                selection=selection_with_subtree,
                all_mover_partitions=all_mover_partitions,
                source_parent_map=source_parent_map,
                dest_parent_map=dest_parent_map,
            )
        )

        trees.extend(step_trees)
        edges.extend(step_edges)
        subtree_tracker.extend(step_subtree_tracker)

    return trees, edges, interpolation_state, subtree_tracker
