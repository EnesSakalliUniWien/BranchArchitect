import os
from . import jt_logger, format_set
from typing import Optional
from brancharchitect.tree import Node
from datetime import datetime
from pathlib import Path


def generate_debug_html(title="Branch Architect Debug Output"):
    """Generate HTML content for debug output."""
    # Get the actual debug content first
    debug_content = jt_logger.get_html_content()
    print(f"Debug content in generate_debug_html: {len(debug_content)} bytes")

    if not debug_content:
        debug_content = "<p>No debug information recorded.</p>"
        print("Warning: No debug content available!")

    # Define CSS styles
    css_styles = """
        /* Reset and base styles */
        * { margin: 0; padding: 0; box-sizing: border-box; }

        /* Core theme */
        body {
            background: #1d1d1d;
            color: #c8c8c8;
            font-family: 'Menlo', 'DejaVu Sans Mono', monospace;
            line-height: 1.6;
            padding: 20px;
            -webkit-font-smoothing: antialiased;
        }

        /* Layout */
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: #222;
            border: 1px solid #333;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }

        /* Headers */
        h1, h2, h3, h4, h5, h6 {
            color: #fff;
            margin: 1em 0 0.5em 0;
            border-bottom: 1px solid #333;
            padding-bottom: 0.3em;
        }

        /* Tables */
        .table-container {
            margin: 1em 0;
            overflow-x: auto;
            background: #252525;
            border-radius: 4px;
            border: 1px solid #333;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9em;
            background: transparent;
        }

        th {
            background: #333;
            color: #fff;
            font-weight: bold;
            text-align: left;
            padding: 12px;
            border: 1px solid #444;
        }

        td {
            padding: 10px 12px;
            border: 1px solid #444;
            color: #c8c8c8;
        }

        tr:hover {
            background: #2a2a2a;
        }

        /* SVG containers */
        .svg-container {
            background: #252525;
            padding: 20px;
            margin: 1em 0;
            border-radius: 4px;
            border: 1px solid #333;
            overflow-x: auto;
        }

        .svg-container svg {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 0 auto;
        }

        /* Analysis cards */
        .bidirectional-analysis {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 1em 0;
        }

        .analysis-card {
            background: #252525;
            border: 1px solid #333;
            padding: 15px;
            border-radius: 4px;
        }

        .analysis-detail {
            margin: 8px 0;
            display: flex;
            justify-content: space-between;
            border-bottom: 1px solid #333;
            padding-bottom: 4px;
        }

        .detail-label {
            color: #888;
            margin-right: 10px;
        }

        /* Messages */
        .warning { color: #ffd700; }
        .error { color: #ff6b6b; }
        .success { color: #6bff6b; }

        /* Code blocks */
        pre {
            background: #252525;
            padding: 15px;
            border-radius: 4px;
            overflow-x: auto;
            border: 1px solid #333;
            margin: 1em 0;
        }

        /* Links */
        a {
            color: #4a9eff;
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }
    """

    # Create HTML structure
    html_content = f"""<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{title}</title>
    <style>{css_styles}</style>
</head>
<body>
    <div class="container">
        <header>
            <h1>{title}</h1>
        </header>
        <main>
            {debug_content}
        </main>
        <footer>
            <p style="margin-top: 2em; text-align: center; color: #666;">
                Generated by Branch Architect
            </p>
        </footer>
    </div>
</body>
</html>"""

    return html_content


def write_debug_output(
    html_content: Optional[str] = None,
    output_path: Optional[str] = None,
    title: str = "Branch Architect Debug Output",
) -> Optional[str]:
    """Write HTML debug output to a file."""
    try:
        # Generate HTML only once
        if html_content is None:
            html_content = generate_debug_html(title)

        # Set default output path if needed
        if output_path is None:
            output_dir = os.path.join(
                os.path.dirname(
                    os.path.dirname(os.path.dirname(os.path.dirname(__file__)))
                ),
                "output",
                "debug",
            )
            os.makedirs(output_dir, exist_ok=True)
            output_path = os.path.join(output_dir, "debug_output.html")

        # Write file
        with open(output_path, "w", encoding="utf-8") as f:
            f.write(html_content)
        return output_path

    except Exception as e:
        print(f"Error writing debug output: {str(e)}")
        return None


def log_tree_splits(
    tree1: Node, tree2: Node, title: str = "Tree Split Comparison"
) -> None:
    """Log a side-by-side comparison of splits between two trees with detailed diagnostics."""
    jt_logger.section(title)

    # Get splits using the tree's internal order
    splits1 = tree1.to_splits(with_leaves=True)
    splits2 = tree2.to_splits(with_leaves=True)

    # Log the order/mapping with more detail
    order_map = tree1.split_indices.reverse_lookup

    # Create comparison table with correlation between indices and taxa
    table_data = [
        ["Left Indices", "Left Taxa", "Right Indices", "Right Taxa", "Common?"]
    ]

    # Get all splits sorted by size for consistent ordering
    splits1_sorted = sorted(splits1, key=lambda x: (len(x.indices), x.indices))
    splits2_sorted = sorted(splits2, key=lambda x: (len(x.indices), x.indices))

    # Make lists equal length for table
    max_len = max(len(splits1_sorted), len(splits2_sorted))
    splits1_padded = splits1_sorted + [None] * (max_len - len(splits1_sorted))
    splits2_padded = splits2_sorted + [None] * (max_len - len(splits2_sorted))

    # Track potential encoding mismatches
    mismatches = []

    # Create rows with split indices and taxa
    for split1, split2 in zip(splits1_padded, splits2_padded):
        # Check if the taxa match their indices
        if split1 and split2:
            expected_taxa1 = {order_map[i] for i in split1.indices}
            expected_taxa2 = {order_map[i] for i in split2.indices}

            if expected_taxa1 != split1.taxa or expected_taxa2 != split2.taxa:
                mismatches.append(
                    {
                        "left_indices": split1.indices,
                        "left_taxa": split1.taxa,
                        "left_expected": expected_taxa1,
                        "right_indices": split2.indices,
                        "right_taxa": split2.taxa,
                        "right_expected": expected_taxa2,
                    }
                )

        is_common = (
            split1
            and split2
            and split1.indices == split2.indices
            and split1.taxa == split2.taxa
        )

        row = [
            format_set(split1.indices) if split1 else "—",
            format_set(split1.taxa) if split1 else "—",
            format_set(split2.indices) if split2 else "—",
            format_set(split2.taxa) if split2 else "—",
            "✓" if is_common else "✗",
        ]
        table_data.append(row)

    # Log the comparison table
    jt_logger.table(
        table_data[1:], headers=table_data[0], title="Split Comparison", tablefmt="grid"
    )

    # Add CSS for new elements
    jt_logger.add_css(
        """
        .tree-analysis {
            margin: 1em 0;
            padding: 1em;
            background: #252525;
            border-radius: 4px;
        }
        .tree-details {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1em;
        }
        .detail-block {
            padding: 1em;
            background: #2d2d2d;
            border-radius: 4px;
        }
        .mismatch-analysis {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1em;
            margin-top: 1em;
        }
        .tree-side {
            padding: 1em;
            background: #2d2d2d;
            border-radius: 4px;
        }
    """
    )

    # Log summary info with enhanced statistics
    jt_logger.info("\nSplit Statistics:")
    jt_logger.info(f"Left Tree Splits: {len(splits1)}")
    jt_logger.info(f"Right Tree Splits: {len(splits2)}")
    jt_logger.info(f"Common Splits: {len(splits1 & splits2)}")
    jt_logger.info(f"Mismatches Found: {len(mismatches)}")


def create_debug_index():
    """
    Creates an 'index.html' in 'output/test_debug' that lists all debug
    HTML files (except index.html) sorted by creation time (newest first).
    """
    print("Starting index creation process...")

    # Use the project root instead of the current file's directory
    project_root = Path(__file__).parent.parent.parent.parent
    output_dir = project_root / "output" / "test_debug"
    output_dir.mkdir(parents=True, exist_ok=True)

    print(f"Creating index in: {output_dir}")  # Debug print

    # Gather debug HTML files in 'output/test_debug'
    debug_files = []
    for file in output_dir.glob("*.html"):
        if file.name.lower() == "index.html":
            continue  # skip existing index
        creation_time = os.path.getctime(file)
        size_kb = file.stat().st_size / 1024

        # Extract test name
        test_name = file.stem
        if test_name.startswith("debug_log_"):
            test_name = test_name[len("debug_log_") :]
        test_name = test_name.replace("_", " ").title()

        debug_files.append(
            {
                "filename": file.name,
                "created": datetime.fromtimestamp(creation_time),
                "size": size_kb,
                "test_name": test_name,
                "path": file.name,  # Just use the filename since we're in the same directory
            }
        )

    # Sort files by creation time (descending)
    debug_files.sort(key=lambda x: x["created"], reverse=True)

    # Build HTML content
    latest_run = (
        debug_files[0]["created"].strftime("%Y-%m-%d %H:%M:%S")
        if debug_files
        else "N/A"
    )
    html = f"""<!DOCTYPE html>
<html>
<head>
    <title>BranchArchitect Test Debug Index</title>
    <style>
        body {{ font-family: sans-serif; margin: 20px; background-color: #f8f9fa; }}
        h1 {{ color: #333; margin-bottom: 20px; }}
        .header {{ display: flex; justify-content: space-between; align-items: center; }}
        .stats {{ font-size: 0.9em; color: #666; }}
        table {{ border-collapse: collapse; width: 100%; background-color: #fff; box-shadow: 0 1px 3px rgba(0,0,0,0.12); }}
        th, td {{ padding: 12px; text-align: left; border-bottom: 1px solid #ddd; }}
        th {{ background-color: #f2f2f2; cursor: pointer; }}
        tr:hover {{ background-color: #f5f5f5; }}
        .timestamp {{ font-size: 0.9em; color: #666; }}
        .file-size {{ text-align: right; }}
        a {{ color: #0366d6; text-decoration: none; }}
        a:hover {{ text-decoration: underline; }}
        .search {{ margin-bottom: 20px; padding: 8px; width: 100%; border: 1px solid #ddd; border-radius: 4px; }}
        footer {{ margin-top: 30px; text-align: center; font-size: 0.8em; color: #666; }}
    </style>
</head>
<body>
    <div class="header">
        <h1>BranchArchitect Test Debug Index</h1>
        <div class="stats">
            <strong>Total Files:</strong> {len(debug_files)} |
            <strong>Last Run:</strong> {latest_run}
        </div>
    </div>

    <input type="text" class="search" id="searchInput" placeholder="Search for test names..." />

    <table id="debugTable">
        <thead>
            <tr>
                <th onclick="sortTable(0)">Test Name ↕</th>
                <th onclick="sortTable(1)">Timestamp ↕</th>
                <th onclick="sortTable(2)">Size (KB) ↕</th>
            </tr>
        </thead>
        <tbody>
    """

    for file_info in debug_files:
        created_str = file_info["created"].strftime("%Y-%m-%d %H:%M:%S")
        html += f"""
            <tr>
                <td><a href="{file_info["path"]}">{file_info["test_name"]}</a></td>
                <td class="timestamp">{created_str}</td>
                <td class="file-size">{file_info["size"]:.1f}</td>
            </tr>
        """

    html += f"""
        </tbody>
    </table>

    <footer>
        <p>Last updated: {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}</p>
    </footer>

    <script>
    // Simple search
    const searchInput = document.getElementById('searchInput');
    searchInput.addEventListener('keyup', function() {{
        const query = searchInput.value.toLowerCase();
        const rows = document.querySelectorAll('#debugTable tbody tr');
        rows.forEach(row => {{
            row.style.display = row.textContent.toLowerCase().includes(query) ? '' : 'none';
        }});
    }});

    // Sort table columns
    function sortTable(n) {{
        const table = document.getElementById("debugTable");
        let switching = true, dir = "asc", switchcount = 0;
        while (switching) {{
            switching = false;
            const rows = table.rows;
            for (let i = 1; i < rows.length - 1; i++) {{
                let shouldSwitch = false;
                const x = rows[i].getElementsByTagName("TD")[n];
                const y = rows[i + 1].getElementsByTagName("TD")[n];
                if (dir === "asc" && x.innerHTML.toLowerCase() > y.innerHTML.toLowerCase()) {{
                    shouldSwitch = true; break;
                }} else if (dir === "desc" && x.innerHTML.toLowerCase() < y.innerHTML.toLowerCase()) {{
                    shouldSwitch = true; break;
                }}
            }}
            if (shouldSwitch) {{
                rows[i].parentNode.insertBefore(rows[i + 1], rows[i]);
                switching = true;
                switchcount++;
            }} else {{
                if (switchcount === 0 && dir === "asc") {{
                    dir = "desc";
                    switching = true;
                }}
            }}
        }}
    }}
    </script>
</body>
</html>
"""

    # Write the final index
    index_path = output_dir / "index.html"
    with open(index_path, "w", encoding="utf-8") as f:
        f.write(html)

    # Confirm success
    if os.path.exists(index_path):
        print(
            f"Index file created at: {index_path} ({os.path.getsize(index_path)} bytes)"
        )
    else:
        print("WARNING: Index file creation failed!")

    return str(index_path)
