import os
from . import jt_logger, format_set
from brancharchitect.core.html_content import DEBUG_PAGE_CSS
from typing import Optional, List, Dict, Any
from brancharchitect.tree import Node
from datetime import datetime
from pathlib import Path


def generate_debug_html(title: str = "Branch Architect Debug Output"):
    """Generate HTML content for debug output."""
    # Get the actual debug content and any accumulated CSS from the logger
    debug_content = jt_logger.get_html_content()
    logger_css = jt_logger.get_css_content()
    if not debug_content:
        debug_content = "<p>No debug information recorded.</p>"

    # Create HTML structure
    html_content = f"""<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{title}</title>
    <style>{DEBUG_PAGE_CSS}\n{logger_css}</style>
</head>
<body>
    <div class="container">
        <header>
            <h1>{title}</h1>
        </header>
        <main>
            {debug_content}
        </main>
        <footer>
            <p style="margin-top: 2em; text-align: center; color: #666;">
                Generated by Branch Architect
            </p>
        </footer>
    </div>
</body>
</html>"""

    return html_content


def write_debug_output(
    html_content: Optional[str] = None,
    output_path: Optional[str] = None,
    title: str = "Branch Architect Debug Output",
) -> Optional[str]:
    """Write HTML debug output to a file."""
    try:
        # Generate HTML only once
        if html_content is None:
            html_content = generate_debug_html(title)

        # Set default output path if needed
        if output_path is None:
            output_dir = os.path.join(
                os.path.dirname(
                    os.path.dirname(os.path.dirname(os.path.dirname(__file__)))
                ),
                "output",
                "debug",
            )
            os.makedirs(output_dir, exist_ok=True)
            output_path = os.path.join(output_dir, "debug_output.html")

        # Write file
        with open(output_path, "w", encoding="utf-8") as f:
            f.write(html_content)
        return output_path

    except Exception as e:
        print(f"Error writing debug output: {str(e)}")
        return None


def log_tree_splits(
    tree1: Node, tree2: Node, title: str = "Tree Split Comparison"
) -> None:
    """Log a side-by-side comparison of splits between two trees with detailed diagnostics."""
    jt_logger.section(title)

    # Get splits using the tree's internal order
    splits1 = tree1.to_splits(with_leaves=True)
    splits2 = tree2.to_splits(with_leaves=True)

    # Log the order/mapping with more detail
    order_map = tree1.split_indices.reverse_encoding

    # Create comparison table with correlation between indices and taxa
    table_data = [
        ["Left Indices", "Left Taxa", "Right Indices", "Right Taxa", "Common?"]
    ]

    # Get all splits sorted by size for consistent ordering
    splits1_sorted = sorted(splits1, key=lambda x: (len(x.indices), x.indices))
    splits2_sorted = sorted(splits2, key=lambda x: (len(x.indices), x.indices))

    # Make lists equal length for table
    max_len = max(len(splits1_sorted), len(splits2_sorted))
    splits1_padded = splits1_sorted + [None] * (max_len - len(splits1_sorted))
    splits2_padded = splits2_sorted + [None] * (max_len - len(splits2_sorted))

    # Track potential encoding mismatches
    mismatches = []

    # Create rows with split indices and taxa
    for split1, split2 in zip(splits1_padded, splits2_padded):
        # Check if the taxa match their indices
        if split1 and split2:
            expected_taxa1 = {order_map[i] for i in split1.indices}
            expected_taxa2 = {order_map[i] for i in split2.indices}

            if expected_taxa1 != split1.taxa or expected_taxa2 != split2.taxa:
                mismatches.append(
                    {
                        "left_indices": split1.indices,
                        "left_taxa": split1.taxa,
                        "left_expected": expected_taxa1,
                        "right_indices": split2.indices,
                        "right_taxa": split2.taxa,
                        "right_expected": expected_taxa2,
                    }
                )

        is_common = (
            split1
            and split2
            and split1.indices == split2.indices
            and split1.taxa == split2.taxa
        )

        row = [
            format_set(split1.indices) if split1 else "—",
            format_set(split1.taxa) if split1 else "—",
            format_set(split2.indices) if split2 else "—",
            format_set(split2.taxa) if split2 else "—",
            "✓" if is_common else "✗",
        ]
        table_data.append(row)

    # Log the comparison table
    jt_logger.table(
        table_data[1:], headers=table_data[0], title="Split Comparison", tablefmt="grid"
    )

    # Add CSS for new elements
    jt_logger.add_css(
        """
        .tree-analysis {
            margin: 1em 0;
            padding: 1em;
            background: #252525;
            border-radius: 4px;
        }
        .tree-details {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1em;
        }
        .detail-block {
            padding: 1em;
            background: #2d2d2d;
            border-radius: 4px;
        }
        .mismatch-analysis {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1em;
            margin-top: 1em;
        }
        .tree-side {
            padding: 1em;
            background: #2d2d2d;
            border-radius: 4px;
        }
    """
    )

    # Log summary info with enhanced statistics
    jt_logger.info("\nSplit Statistics:")
    jt_logger.info(f"Left Tree Splits: {len(splits1)}")
    jt_logger.info(f"Right Tree Splits: {len(splits2)}")
    jt_logger.info(f"Common Splits: {len(splits1 & splits2)}")
    jt_logger.info(f"Mismatches Found: {len(mismatches)}")


def create_debug_index(verbose: bool = False):
    """
    Creates an 'index.html' in 'output/test_debug' that lists all debug
    HTML files (except index.html) sorted by creation time (newest first).
    """
    if verbose:
        print("Starting index creation process...")

    # Use the project root instead of the current file's directory
    project_root = Path(__file__).parent.parent.parent.parent
    output_dir = project_root / "test" / "output" / "debug_logs"
    output_dir.mkdir(parents=True, exist_ok=True)

    if verbose:
        print(f"Creating index in: {output_dir}")

    # Gather debug HTML files in 'test/output/debug_logs'
    debug_files: List[Dict[str, Any]] = []
    for file in output_dir.glob("*.html"):
        if file.name.lower() == "index.html":
            continue  # skip existing index
        creation_time = os.path.getctime(file)
        size_kb = file.stat().st_size / 1024

        # Extract test name
        test_name = file.stem
        if test_name.startswith("debug_log_"):
            test_name = test_name[len("debug_log_") :]
        test_name = test_name.replace("_", " ").title()

        debug_files.append(
            {
                "filename": file.name,
                "created": datetime.fromtimestamp(creation_time),
                "size": size_kb,
                "test_name": test_name,
                "path": file.name,  # Just use the filename since we're in the same directory
            }
        )

    # Sort files by creation time (descending)
    debug_files.sort(key=lambda x: x["created"], reverse=True)

    # Build HTML content
    latest_run = (
        debug_files[0]["created"].strftime("%Y-%m-%d %H:%M:%S")
        if debug_files
        else "N/A"
    )
    html = f"""<!DOCTYPE html>
<html>
<head>
    <title>BranchArchitect Test Debug Index</title>
    <style>
        body {{ font-family: sans-serif; margin: 20px; background-color: #f8f9fa; }}
        h1 {{ color: #333; margin-bottom: 20px; }}
        .header {{ display: flex; justify-content: space-between; align-items: center; }}
        .stats {{ font-size: 0.9em; color: #666; }}
        table {{ border-collapse: collapse; width: 100%; background-color: #fff; box-shadow: 0 1px 3px rgba(0,0,0,0.12); }}
        th, td {{ padding: 12px; text-align: left; border-bottom: 1px solid #ddd; }}
        th {{ background-color: #f2f2f2; cursor: pointer; }}
        tr:hover {{ background-color: #f5f5f5; }}
        .timestamp {{ font-size: 0.9em; color: #666; }}
        .file-size {{ text-align: right; }}
        a {{ color: #0366d6; text-decoration: none; }}
        a:hover {{ text-decoration: underline; }}
        .search {{ margin-bottom: 20px; padding: 8px; width: 100%; border: 1px solid #ddd; border-radius: 4px; }}
        footer {{ margin-top: 30px; text-align: center; font-size: 0.8em; color: #666; }}
    </style>
</head>
<body>
    <div class="header">
        <h1>BranchArchitect Test Debug Index</h1>
        <div class="stats">
            <strong>Total Files:</strong> {len(debug_files)} |
            <strong>Last Run:</strong> {latest_run}
        </div>
    </div>

    <input type="text" class="search" id="searchInput" placeholder="Search for test names..." />

    <table id="debugTable">
        <thead>
            <tr>
                <th onclick="sortTable(0)">Test Name ↕</th>
                <th onclick="sortTable(1)">Timestamp ↕</th>
                <th onclick="sortTable(2)">Size (KB) ↕</th>
            </tr>
        </thead>
        <tbody>
    """

    for file_info in debug_files:
        created_str = file_info["created"].strftime("%Y-%m-%d %H:%M:%S")
        html += f"""
            <tr>
                <td><a href="{file_info["path"]}">{file_info["test_name"]}</a></td>
                <td class="timestamp">{created_str}</td>
                <td class="file-size">{file_info["size"]:.1f}</td>
            </tr>
        """

    html += f"""
        </tbody>
    </table>

    <footer>
        <p>Last updated: {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}</p>
    </footer>

    <script>
    // Simple search
    const searchInput = document.getElementById('searchInput');
    searchInput.addEventListener('keyup', function() {{
        const query = searchInput.value.toLowerCase();
        const rows = document.querySelectorAll('#debugTable tbody tr');
        rows.forEach(row => {{
            row.style.display = row.textContent.toLowerCase().includes(query) ? '' : 'none';
        }});
    }});

    // Sort table columns
    function sortTable(n) {{
        const table = document.getElementById("debugTable");
        let switching = true, dir = "asc", switchcount = 0;
        while (switching) {{
            switching = false;
            const rows = table.rows;
            for (let i = 1; i < rows.length - 1; i++) {{
                let shouldSwitch = false;
                const x = rows[i].getElementsByTagName("TD")[n];
                const y = rows[i + 1].getElementsByTagName("TD")[n];
                if (dir === "asc" && x.innerHTML.toLowerCase() > y.innerHTML.toLowerCase()) {{
                    shouldSwitch = true; break;
                }} else if (dir === "desc" && x.innerHTML.toLowerCase() < y.innerHTML.toLowerCase()) {{
                    shouldSwitch = true; break;
                }}
            }}
            if (shouldSwitch) {{
                rows[i].parentNode.insertBefore(rows[i + 1], rows[i]);
                switching = true;
                switchcount++;
            }} else {{
                if (switchcount === 0 && dir === "asc") {{
                    dir = "desc";
                    switching = true;
                }}
            }}
        }}
    }}
    </script>
</body>
</html>
"""

    # Write the final index
    index_path = output_dir / "index.html"
    with open(index_path, "w", encoding="utf-8") as f:
        f.write(html)

    # Confirm success
    if verbose:
        if os.path.exists(index_path):
            print(
                f"Index file created at: {index_path} ({os.path.getsize(index_path)} bytes)"
            )
        else:
            print("WARNING: Index file creation failed!")

    return str(index_path)
